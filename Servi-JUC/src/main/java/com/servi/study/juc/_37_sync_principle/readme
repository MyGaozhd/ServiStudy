synchronized的底层实现
JDK早期的1.6以前 重量级 - OS
后来的改进
锁升级的概念：
sync (Object)
markword 记录这个线程ID （偏向锁） 偏向鎖：只是在markword 里面记录了线程id 但是此时其实是没有锁的状态
如果线程争用：升级为 自旋锁
10次以后，或者 自旋的线程数超过cpu的1/2

升级为重量级锁 - OS
mutex 这是有数量限制的

执行时间短（加锁代码），线程数少，用自旋
执行时间长，线程数多，用系统锁

无锁态 -> 偏向锁 -> 自旋锁(轻量级锁、无锁) -> 重量级锁

偏向鎖 -> 自旋锁的过程：
首先，撤销偏向锁状态。
每个线程在自己的线程栈中生成一个 LockRecord 指针。看谁能把自己的LockRecord贴到 对象的markword中。
贴的过程是自旋方式的。
